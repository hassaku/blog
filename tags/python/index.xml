<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on hassaku&#39;s blog</title>
    <link>http://blog.hassaku-labs.com/tags/python/</link>
    <description>Recent content in Python on hassaku&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Mon, 23 Apr 2018 00:00:00 +0900</lastBuildDate>
    <atom:link href="http://blog.hassaku-labs.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ターミナル上で１行の簡易グラフ</title>
      <link>http://blog.hassaku-labs.com/post/ascii-simple-plot/</link>
      <pubDate>Mon, 23 Apr 2018 00:00:00 +0900</pubDate>
      
      <guid>http://blog.hassaku-labs.com/post/ascii-simple-plot/</guid>
      <description>&lt;p&gt;データ処理などしていると、処理中の状況を確認するのに、数値や文字列よりもグラフの方が適していることが多い。
ただ、そのためだけにGUIなどを用意するのは大変だし、出来ればターミナル上で表示したい。
というわけで、ログなど混ぜて、以下のような感じで、簡易的にグラフ描くと便利。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat simple_plot.py

# coding: utf-8

import numpy as np

TICKS = u&#39;_▁▂▃▄▅▆▇█&#39;

def ascii_plot(ints, max_range=None, min_range=0, width=40):
    assert len(ints) &amp;gt;= width

    ints = np.array(ints, dtype=int)
    ints = ints[:int(len(ints)/width)*width]
    ints = np.nansum(np.reshape(ints, (int(len(ints)/width), width)).T, axis=1)

    if not max_range:
        max_range = max(ints)
    if not min_range:
        min_range = min(ints)

    step_range = max_range - min_range
    step = (step_range / float(len(TICKS) - 1)) or 1
    return u&#39;&#39;.join(TICKS[int(round((i - min_range) / step))] for i in ints)


if __name__ == &amp;quot;__main__&amp;quot;:
   print(ascii_plot(range(10) + range(10, 0, -1), width=20))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ python simple_plot.py
_▁▂▂▃▄▅▆▆▇█▇▆▆▅▄▃▂▂▁
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>hyperoptでパラメータサーチ</title>
      <link>http://blog.hassaku-labs.com/post/hyperopt/</link>
      <pubDate>Sat, 04 Mar 2017 04:08:51 +0900</pubDate>
      
      <guid>http://blog.hassaku-labs.com/post/hyperopt/</guid>
      <description>

&lt;p&gt;機械学習におけるモデルのハイパーパラメータ探索は、その後のモデル評価を正当に行うことにも繋がる、重要な作業です。
近年ではRandom SearchやGrid Search、GA等の各種最適化手法よりも、色々と優れた手法が提案されているらしく、
手軽に使えるようなライブラリも整備されています。
パラメータ探索技術というと、応用範囲が広く、効果が見えやすいため、手軽に使えて効率的な手法があれば、積極的に使っていきたいところです。
その中でもhyperoptというライブラリが、kaggleとかでよく使われているという話を見かけて、試しに使ってみました。&lt;/p&gt;

&lt;p&gt;中身については、色々Blogや論文が見つかるのですが、
Bayesian Optimization -&amp;gt; Sequential Model-based Algorithm Configuration (SMAC) -&amp;gt; Tree-structured Parzen Estimator (TPE)
のように進化してきたTPEという手法が使われているようです。
Bayesian Optimizationのアプローチは、直感的にも効率良さそうなので、その進化系なら期待できます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://hyperopt.github.io/hyperopt/&#34;&gt;Hyperopt&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;簡単な使い方:3ef796ded5fdc2a18d77f9e19d0b06e3&#34;&gt;簡単な使い方&lt;/h2&gt;

&lt;p&gt;以下のような感じで、簡単に記述出来て、手軽に取り入れられそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# encoding: utf-8

import os
import sys

import matplotlib.pyplot as plt
import numpy as np
from hyperopt import fmin, tpe, hp, Trials

# パラメータの探索範囲。指定方法は離散値や連続値などに応じて色々ある。
# https://github.com/hyperopt/hyperopt/wiki/FMin#21-parameter-expressions
hyperopt_parameters = { &#39;x&#39;: hp.uniform(&#39;x&#39;, -30, 30) }

# 最小化したい目的関数。正解との誤差とか。
def objective(args):
    return np.sin(args[&#39;x&#39;]) / args[&#39;x&#39;]

# 探索中の進行状況を記録
trials = Trials()

# パラメータサーチの実行
best = fmin(objective,  hyperopt_parameters, algo=tpe.suggest, max_evals=300, trials=trials)

# 目的関数を最小にするパラメータ
print best
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パラメータサーチの様子を表示:3ef796ded5fdc2a18d77f9e19d0b06e3&#34;&gt;パラメータサーチの様子を表示&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 上記コードの続き

x_hisotry = np.ravel([t[&#39;misc&#39;][&#39;vals&#39;][&#39;x&#39;] for t in trials.trials])
objective_history = trials.losses()

fig = plt.figure(figsize=(16, 8))
cm = plt.get_cmap(&#39;jet&#39;)

PLOT_NUM = 5

for i, hist_num in enumerate(np.linspace(50, 300, PLOT_NUM)):
    cmap_cycle = [cm(1. * h/ (hist_num - 1)) for h in range(int(hist_num) - 1)]

    ax = plt.subplot(2, PLOT_NUM, i + 1)
    ax.set_color_cycle(cmap_cycle)
    ax.plot(np.arange(-30, 30, 0.1), function(np.arange(-30, 30, 0.1)), alpha=0.2)
    for j in range(int(hist_num)  - 1):
        ax.plot(x_hisotry[j], objective_history[j], &#39;.&#39;)
    ax.set_title(&#39;times: {times}&#39;.format(times=int(hist_num)))
    ax.set_ylim([np.min(objective_history) - 0.1, np.max(objective_history) + 0.1])
    ax.set_xlim([-30, 30])
    if i == 0:
        ax.set_ylabel(&#39;y&#39;)

    plt.subplot(2, PLOT_NUM, PLOT_NUM + i + 1)
    plt.hist(x_hisotry[:hist_num], bins=50)
    if i == 0:
        plt.ylabel(&#39;histogram of x&#39;)
    plt.xlabel(&#39;x&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hassaku-labs.com/images/post/hyperopt/hyperopt.png&#34; alt=&#34;hyperopt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;右に進むに連れて、パラメータ探索が進んでいく様子を表しています。
上段の図が、目的関数と探索点の描画です。x=0の点が求めたいパラメータとなります。
下段の図が、各探索点のヒストグラムを描画しているのですが、探索が進むにつれて、
目標のパラメータ付近を効率的に探索している様子が分かります。&lt;/p&gt;

&lt;h4 id=&#34;追記:3ef796ded5fdc2a18d77f9e19d0b06e3&#34;&gt;追記&lt;/h4&gt;

&lt;p&gt;バンディットベースのものが出たらしい。使い方もhyperopt同様に簡単そうなので、パラメータチューニング時の候補にしたい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zygmuntz/hyperband&#34;&gt;Hyperband&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>インスタンスを表す文字列を分かりやすくする</title>
      <link>http://blog.hassaku-labs.com/post/class-repr/</link>
      <pubDate>Sat, 04 Mar 2017 04:07:38 +0900</pubDate>
      
      <guid>http://blog.hassaku-labs.com/post/class-repr/</guid>
      <description>

&lt;p&gt;ログとかにインスタンスの内容をダンプしたりするとき、つい適当にprintとかlogger.debugしても、
標準では、インスタンスの内容をスマートに分かりやすく表示してくれたりはしないようです。&lt;/p&gt;

&lt;p&gt;そのため、デバッグをしやすくするためにも、以下のような感じで__repr__をオーバーライドしておくと、
分かりやすくなって便利だったりします。&lt;/p&gt;

&lt;h2 id=&#34;reprを定義しない場合:9c4edd90300eaacc62e25ae2f1faec5e&#34;&gt;reprを定義しない場合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class MyClass(object):
  def __init__(self):
    self.attr1 = 123
    self.attr2 = 456

mc = MyClass()
print(mc)  # =&amp;gt; &amp;lt;__main__.MyClass object at 0xXXXXXXXXXX&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reprを定義する場合:9c4edd90300eaacc62e25ae2f1faec5e&#34;&gt;reprを定義する場合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class MyClass(object):
  def __init__(self):
    self.attr1 = 123
    self.attr2 = 456

  def __repr__(self):
    return &amp;quot;, &amp;quot;.join(&amp;quot;%s: %s&amp;quot; % item for item in vars(self).items())

mc = MyClass()
print(mc)  # =&amp;gt; attr2: 456, attr1: 123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとしたTipsでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>exception-slackerというライブラリをPyPIに登録した</title>
      <link>http://blog.hassaku-labs.com/post/exception_slacker/</link>
      <pubDate>Fri, 01 Apr 2016 00:35:40 +0900</pubDate>
      
      <guid>http://blog.hassaku-labs.com/post/exception_slacker/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/hassaku/exception-slacker&#34;&gt;https://github.com/hassaku/exception-slacker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;importして、Slackのtokenや投稿チャンネルなどを環境変数でセットしておけば、例外が発生した際に、以下のような感じでSlackへ投稿します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hassaku-labs.com/images/post/exception_slacker/exception_slacker.png&#34; alt=&#34;exception_slacker&#34; /&gt;&lt;/p&gt;

&lt;p&gt;時間のかかるプロセスなどを実行している時に、いちいちコンソールをチェックする手間が省けるので、個人的に便利だと思って公開しました。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>