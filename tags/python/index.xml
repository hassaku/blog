<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on hassaku&#39;s blog</title>
    <link>https://blog.hassaku-labs.com/tags/python/</link>
    <description>Recent content in Python on hassaku&#39;s blog</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 03 May 2019 10:00:00 +0900</lastBuildDate>
    <atom:link href="https://blog.hassaku-labs.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>データ分析コンペとかによくやる作業</title>
      <link>https://blog.hassaku-labs.com/post/data-comp-memo/</link>
      <pubDate>Fri, 03 May 2019 10:00:00 +0900</pubDate>
      <guid>https://blog.hassaku-labs.com/post/data-comp-memo/</guid>
      <description>&lt;h1 id=&#34;大きいデータの読み込み&#34;&gt;大きいデータの読み込み&lt;/h1&gt;&#xA;&lt;p&gt;daskを使って並列処理&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import dask.dataframe as ddf&#xA;import dask.multiprocessing&#xA;&#xA;df = ddf.read_csv(&amp;#39;train_data.csv&amp;#39;)&#xA;df = df.compute(get=dask.multiprocessing.get)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;eda&#34;&gt;EDA&lt;/h1&gt;&#xA;&lt;p&gt;データに関する簡単な統計情報確認&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import pandas_profiling as pdp&#xA;pdp.ProfileReport(df)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;データの相関を確認&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import seaborn as sns&#xA;sns.pairplot(df, hue=&amp;#34;target&amp;#34;, diag_kind=&amp;#34;kde&amp;#34;)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;前処理&#34;&gt;前処理&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;欠損値の補完&lt;/li&gt;&#xA;&lt;li&gt;外れ値の削除&lt;/li&gt;&#xA;&lt;li&gt;カテゴリ変数の扱い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;one hot encoding （次元増える系）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どれかひとつだけ1になるようなスパースなベクトル表現&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;city_dummies = pd.get_dummies(df[&amp;#34;city&amp;#34;], prefix=&amp;#34;city&amp;#34;)&#xA;df.drop([&amp;#34;city&amp;#34;], axis=1, inplca=True)&#xA;df = df.join(city_dummies)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;count encoding （次元増えない系）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;カテゴリ変数の出現回数（あるいは率）を値とするような表現&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;df[&amp;#39;count_city&amp;#39;] = df.groupby(&amp;#39;city&amp;#39;)[&amp;#39;target&amp;#39;].transform(&amp;#39;count&amp;#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;並列処理&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import numpy as np&#xA;import pandas as pd&#xA;#import multiprocessing as mp  # impossible to use lambda with pickle&#xA;import pathos.multiprocessing as mp  # dill is used inside instead of pickle.&#xA;&#xA;def split_parallel(df, num_split, map_func):&#xA;    with mp.Pool(num_split) as p:&#xA;        df_split = np.array_split(df, num_split*2)&#xA;        result = p.map(map_func, df_split)&#xA;    return pd.concat(result)&#xA;&#xA;NUM_PARALLELS = 3&#xA;df[&amp;#34;new_col&amp;#34;] = split_parallel(df, NUM_PARALLELS, lambda x: x[&amp;#34;col1&amp;#34;] + x[&amp;#34;col2&amp;#34;])&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;cv&#34;&gt;CV&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from sklearn.model_selection import StratifiedKFold&#xA;&#xA;cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=123)&#xA;X_train = np.zeros(20, 5)&#xA;y_train = np.zeros(20)&#xA;&#xA;for train_idx, valid_idx in cv.split(X_train, y_train):&#xA;    print(train_idx, valid_idx)&#xA;    ...&#xA;    losses.append(loss)&#xA;&#xA;cv_loss = np.mean(losses)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;結果のアンサンブル&#34;&gt;結果のアンサンブル&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;res1 = pd.read_csv(&amp;#39;../method1/submission.csv&amp;#39;)&#xA;res2 = pd.read_csv(&amp;#39;../method2/submission.csv&amp;#39;)&#xA;res3 = pd.read_csv(&amp;#39;../method3/submission.csv&amp;#39;)&#xA;&#xA;b1 = res1.copy()&#xA;col = res1.columns&#xA;&#xA;col = col.tolist()&#xA;col.remove(&amp;#39;id&amp;#39;)&#xA;for i in col:&#xA;    b1[i] = (2 * res1[i]  + 2 * res2[i] + 4 * res3[i]) / 6.0&#xA;&#xA;b1.to_csv(&amp;#39;submission.csv&amp;#39;, index=False)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;jupyter-notebook上でcsvの確認とダウンロード&#34;&gt;Jupyter Notebook上でCSVの確認とダウンロード&lt;/h1&gt;&#xA;&lt;p&gt;実行するとディレクトリ内のファイル一覧が表示されて、クリックすればダウンロード出来るはず&lt;/p&gt;</description>
    </item>
    <item>
      <title>IDE使えないときの例外時デバッグ</title>
      <link>https://blog.hassaku-labs.com/post/debug-on-remote/</link>
      <pubDate>Mon, 25 Feb 2019 10:00:00 +0900</pubDate>
      <guid>https://blog.hassaku-labs.com/post/debug-on-remote/</guid>
      <description>&lt;p&gt;IDEが使える状況であれば、簡単にデバッガーを使えると思うが、そうでない環境でデバッグしたくなることもある。&#xA;printデバッグも辛いので、以下のような感じで例外時等にpython debuggerを起動出来ると便利。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import sys&#xA;&#xA;def hook(type, value, tb):&#xA;   if hasattr(sys, &amp;#39;ps1&amp;#39;) or not sys.stderr.isatty():&#xA;      sys.__excepthook__(type, value, tb)&#xA;   else:&#xA;      import traceback, pdb&#xA;      traceback.print_exception(type, value, tb)&#xA;      print()&#xA;      pdb.pm()&#xA;&#xA;sys.excepthook = hook&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;というのを適当なところにdebug.pyとして置いておいて、デバッグしたいコード実行時にimportしておくだけ。&#xA;例外が起きるとデバッガが起動し停止するので、そのときの変数の値などを表示したり調べると良い。&lt;/p&gt;&#xA;&lt;p&gt;不必要に毎回デバッガ起動すると面倒なので、普段はimport行をコメントアウトしておくこと。&lt;/p&gt;&#xA;&lt;p&gt;よく使うコマンドは以下のとおり。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;w&#xA;&lt;ul&gt;&#xA;&lt;li&gt;where. スタックトレースを表示する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;u&#xA;&lt;ul&gt;&#xA;&lt;li&gt;up. スタックを一つ上に移動&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;d&#xA;&lt;ul&gt;&#xA;&lt;li&gt;down. スタックを一つ下に移動&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;l [first, last]&#xA;&lt;ul&gt;&#xA;&lt;li&gt;list. 現在のソースコード表示。fist, lastを指定可能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;p [target]&#xA;&lt;ul&gt;&#xA;&lt;li&gt;print. 変数等を表示。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;c&#xA;&lt;ul&gt;&#xA;&lt;li&gt;continue. 次のブレークポイントに当たるまで実行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;s&#xA;&lt;ul&gt;&#xA;&lt;li&gt;step. 現在の行を実行 (関数の中に入る）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;n&#xA;&lt;ul&gt;&#xA;&lt;li&gt;next. 現在の行を実行 (関数の中に入らない）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;q&#xA;&lt;ul&gt;&#xA;&lt;li&gt;quit. デバッガを終了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>word vectorのような読み込みが重たいやつをWebAPI化して軽量化</title>
      <link>https://blog.hassaku-labs.com/post/word-vector-api/</link>
      <pubDate>Mon, 25 Feb 2019 10:00:00 +0900</pubDate>
      <guid>https://blog.hassaku-labs.com/post/word-vector-api/</guid>
      <description>&lt;p&gt;word vectorとかメモリをどデカく使うようなやつは、毎回スクリプトを起動する際に読み込みに時間がかかって辛い。&#xA;そういうのは、極力別のプロセスにして、適当にAPIとか生やして連携するようにしておくと楽チンなので良くやるパターン。&lt;/p&gt;&#xA;&lt;p&gt;以下は、単語ベクトルを返してくれるAPIを作った例。Flask使うとコードもシンプルに実現出来るので良い。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# coding: utf-8&#xA;&#xA;import numpy as np&#xA;import gensim&#xA;from flask import Flask, jsonify, request&#xA;import json&#xA;&#xA;PRETRAINED_W2V_PATH = &amp;#39;./model.bin&amp;#39;&#xA;&#xA;app = Flask(__name__)&#xA;app.config[&amp;#39;JSON_AS_ASCII&amp;#39;] = False&#xA;&#xA;model = gensim.models.KeyedVectors.load_word2vec_format(PRETRAINED_W2V_PATH, binary=True)  # 超時間かかる処理&#xA;&#xA;@app.route(&amp;#39;/word_vector&amp;#39;, methods=[&amp;#39;GET&amp;#39;])&#xA;def word_vector():&#xA;    word = request.args.get(&amp;#39;word&amp;#39;)&#xA;    vector = np.array(model[word]).astype(float).tolist()&#xA;    return jsonify({&amp;#39;vector&amp;#39;: vector}), 200&#xA;&#xA;&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    app.debug = True&#xA;    app.run(host=&amp;#39;0.0.0.0&amp;#39;, port=8888)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下のような感じで単語ベクトルの値をjsonで返してくれる。pythonのスクリプトからはrequestsとかで簡単に取得して扱えるはず。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ curl &amp;#34;http://0.0.0.0:8888/word_vector?word=テスト&amp;#34;&#xA;{&#xA;  &amp;#34;vector&amp;#34;: [&#xA;    0.029713749885559082,&#xA;    -0.6024296283721924,&#xA;    0.9723357558250427,&#xA;    -1.1497808694839478,&#xA;    1.3764394521713257,&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例えば、連続動作しているようなエージェントシミュレータなんかにも、似たような感じでAPI生やして、インタラクションさせることが出来る。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ターミナル上でシンプルなグリッドワールド</title>
      <link>https://blog.hassaku-labs.com/post/grid-world/</link>
      <pubDate>Fri, 10 Aug 2018 10:00:00 +0900</pubDate>
      <guid>https://blog.hassaku-labs.com/post/grid-world/</guid>
      <description>&lt;p&gt;強化学習などでグリッドワールドを使いたいとき、gym-minigridとかpycolabがあるけど、色々いじる必要性もある場合、もっとシンプルなところからはじめたい。&#xA;また、リモートのVMインスタンス上などで気軽に動かしたいので、GUIとかも無しで、ターミナル上で動かしたい。&lt;/p&gt;&#xA;&lt;p&gt;以下のような感じで、cursesを使ってスクラッチで作っても別に難しいことはなかった。&lt;/p&gt;&#xA;&lt;p&gt;こんな感じのやつがターミナル上で動く。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.hassaku-labs.com/images/post/grid-world/grid-world.gif&#34; alt=&#34;grid-world&#34;&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import curses&#xA;import random&#xA;import time&#xA;from datetime import datetime&#xA;&#xA;FIELD = [&amp;#39;#################&amp;#39;,&#xA;         &amp;#39;#       #       #&amp;#39;,&#xA;         &amp;#39;#       #       #&amp;#39;,&#xA;         &amp;#39;#       #       #&amp;#39;,&#xA;         &amp;#39;#               #&amp;#39;,&#xA;         &amp;#39;#       #       #&amp;#39;,&#xA;         &amp;#39;######  #########&amp;#39;,&#xA;         &amp;#39;#       #       #&amp;#39;,&#xA;         &amp;#39;#       #       #&amp;#39;,&#xA;         &amp;#39;#               #&amp;#39;,&#xA;         &amp;#39;#       #       #&amp;#39;,&#xA;         &amp;#39;#       #       #&amp;#39;,&#xA;         &amp;#39;#################&amp;#39;]&#xA;&#xA;&#xA;def draw(screen):&#xA;    for row, line in enumerate(FIELD):&#xA;        for col, tile in enumerate(line):&#xA;            screen.addch(row, col, tile)&#xA;&#xA;&#xA;def main():&#xA;    x = 10&#xA;    y = 10&#xA;&#xA;    try:&#xA;        screen = curses.initscr()&#xA;        screen.nodelay(1)&#xA;        curses.curs_set(0)&#xA;&#xA;        while(True):&#xA;            action = random.randint(1, 5)&#xA;            dx = 0&#xA;            dy = 0&#xA;            if action == 1:&#xA;                dy += 1&#xA;            elif action == 2:&#xA;                dy -= 1&#xA;            elif action == 3:&#xA;                dx += 1&#xA;            elif action == 4:&#xA;                dx -= 1&#xA;            elif action == 5:&#xA;                pass&#xA;            else:&#xA;                raise NotImplementedError()&#xA;&#xA;            # check wall&#xA;            if FIELD[x + dx][y + dy] != &amp;#34;#&amp;#34;:&#xA;                x += dx&#xA;                y += dy&#xA;&#xA;            screen.clear()&#xA;            draw(screen)&#xA;            screen.addch(x, y, &amp;#39;+&amp;#39;) # agent&#xA;&#xA;            screen.addstr(0, 20, datetime.now().strftime(&amp;#34;%Y/%m/%d %H:%M:%S&amp;#34;))&#xA;            screen.addstr(1, 20, &amp;#39;a:{} x:{} y:{}&amp;#39;.format(action, x, y))&#xA;            screen.refresh()&#xA;&#xA;            # quit&#xA;            if(screen.getch() == ord(&amp;#39;q&amp;#39;)):&#xA;                break&#xA;&#xA;            time.sleep(0.2)&#xA;&#xA;        curses.endwin()&#xA;&#xA;    except:&#xA;        pass&#xA;&#xA;    finally:&#xA;        curses.echo()&#xA;        curses.endwin()&#xA;&#xA;&#xA;if __name__ == &amp;#39;__main__&amp;#39;:&#xA;    main()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;もしエージェントとインタラクションしたいと思ったら、flaskとかでapi作って状態変えるのが良いと思う。やり方はまた別の機会に。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ターミナル上で１行の簡易グラフ</title>
      <link>https://blog.hassaku-labs.com/post/ascii-simple-plot/</link>
      <pubDate>Mon, 23 Apr 2018 00:00:00 +0900</pubDate>
      <guid>https://blog.hassaku-labs.com/post/ascii-simple-plot/</guid>
      <description>&lt;p&gt;データ処理などしていると、処理中の状況を確認するのに、数値や文字列よりもグラフの方が適していることが多い。&#xA;ただ、そのためだけにGUIなどを用意するのは大変だし、出来ればターミナル上で表示したい。&#xA;というわけで、ログなど混ぜて、以下のような感じで、簡易的にグラフ描くと便利。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ cat simple_plot.py&#xA;&#xA;# coding: utf-8&#xA;&#xA;import numpy as np&#xA;&#xA;TICKS = u&amp;#39;_▁▂▃▄▅▆▇█&amp;#39;&#xA;&#xA;def ascii_plot(ints, max_range=None, min_range=0, width=40):&#xA;    assert len(ints) &amp;gt;= width&#xA;&#xA;    ints = np.array(ints, dtype=int)&#xA;    ints = ints[:int(len(ints)/width)*width]&#xA;    ints = np.nansum(np.reshape(ints, (int(len(ints)/width), width)).T, axis=1)&#xA;&#xA;    if not max_range:&#xA;        max_range = max(ints)&#xA;    if not min_range:&#xA;        min_range = min(ints)&#xA;&#xA;    step_range = max_range - min_range&#xA;    step = (step_range / float(len(TICKS) - 1)) or 1&#xA;    return u&amp;#39;&amp;#39;.join(TICKS[int(round((i - min_range) / step))] for i in ints)&#xA;&#xA;&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;   print(ascii_plot(range(10) + range(10, 0, -1), width=20))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ python simple_plot.py&#xA;_▁▂▂▃▄▅▆▆▇█▇▆▆▅▄▃▂▂▁&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>hyperoptでパラメータサーチ</title>
      <link>https://blog.hassaku-labs.com/post/hyperopt/</link>
      <pubDate>Sat, 04 Mar 2017 04:08:51 +0900</pubDate>
      <guid>https://blog.hassaku-labs.com/post/hyperopt/</guid>
      <description>&lt;p&gt;機械学習におけるモデルのハイパーパラメータ探索は、その後のモデル評価を正当に行うことにも繋がる、重要な作業です。&#xA;近年ではRandom SearchやGrid Search、GA等の各種最適化手法よりも、色々と優れた手法が提案されているらしく、&#xA;手軽に使えるようなライブラリも整備されています。&#xA;パラメータ探索技術というと、応用範囲が広く、効果が見えやすいため、手軽に使えて効率的な手法があれば、積極的に使っていきたいところです。&#xA;その中でもhyperoptというライブラリが、kaggleとかでよく使われているという話を見かけて、試しに使ってみました。&lt;/p&gt;&#xA;&lt;p&gt;中身については、色々Blogや論文が見つかるのですが、&#xA;Bayesian Optimization -&amp;gt; Sequential Model-based Algorithm Configuration (SMAC) -&amp;gt; Tree-structured Parzen Estimator (TPE)&#xA;のように進化してきたTPEという手法が使われているようです。&#xA;Bayesian Optimizationのアプローチは、直感的にも効率良さそうなので、その進化系なら期待できます。&lt;/p&gt;&#xA;&lt;p&gt;[Hyperopt]&#xA;(&lt;a href=&#34;http://hyperopt.github.io/hyperopt/&#34;&gt;http://hyperopt.github.io/hyperopt/&lt;/a&gt;)&lt;/p&gt;&#xA;&lt;h2 id=&#34;簡単な使い方&#34;&gt;簡単な使い方&lt;/h2&gt;&#xA;&lt;p&gt;以下のような感じで、簡単に記述出来て、手軽に取り入れられそうです。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#!/usr/bin/env python&#xA;# encoding: utf-8&#xA;&#xA;import os&#xA;import sys&#xA;&#xA;import matplotlib.pyplot as plt&#xA;import numpy as np&#xA;from hyperopt import fmin, tpe, hp, Trials&#xA;&#xA;# パラメータの探索範囲。指定方法は離散値や連続値などに応じて色々ある。&#xA;# https://github.com/hyperopt/hyperopt/wiki/FMin#21-parameter-expressions&#xA;hyperopt_parameters = { &amp;#39;x&amp;#39;: hp.uniform(&amp;#39;x&amp;#39;, -30, 30) }&#xA;&#xA;# 最小化したい目的関数。正解との誤差とか。&#xA;def objective(args):&#xA;    return np.sin(args[&amp;#39;x&amp;#39;]) / args[&amp;#39;x&amp;#39;]&#xA;&#xA;# 探索中の進行状況を記録&#xA;trials = Trials()&#xA;&#xA;# パラメータサーチの実行&#xA;best = fmin(objective,  hyperopt_parameters, algo=tpe.suggest, max_evals=300, trials=trials)&#xA;&#xA;# 目的関数を最小にするパラメータ&#xA;print best&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;パラメータサーチの様子を表示&#34;&gt;パラメータサーチの様子を表示&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 上記コードの続き&#xA;&#xA;x_hisotry = np.ravel([t[&amp;#39;misc&amp;#39;][&amp;#39;vals&amp;#39;][&amp;#39;x&amp;#39;] for t in trials.trials])&#xA;objective_history = trials.losses()&#xA;&#xA;fig = plt.figure(figsize=(16, 8))&#xA;cm = plt.get_cmap(&amp;#39;jet&amp;#39;)&#xA;&#xA;PLOT_NUM = 5&#xA;&#xA;for i, hist_num in enumerate(np.linspace(50, 300, PLOT_NUM)):&#xA;    cmap_cycle = [cm(1. * h/ (hist_num - 1)) for h in range(int(hist_num) - 1)]&#xA;&#xA;    ax = plt.subplot(2, PLOT_NUM, i + 1)&#xA;    ax.set_color_cycle(cmap_cycle)&#xA;    ax.plot(np.arange(-30, 30, 0.1), function(np.arange(-30, 30, 0.1)), alpha=0.2)&#xA;    for j in range(int(hist_num)  - 1):&#xA;        ax.plot(x_hisotry[j], objective_history[j], &amp;#39;.&amp;#39;)&#xA;    ax.set_title(&amp;#39;times: {times}&amp;#39;.format(times=int(hist_num)))&#xA;    ax.set_ylim([np.min(objective_history) - 0.1, np.max(objective_history) + 0.1])&#xA;    ax.set_xlim([-30, 30])&#xA;    if i == 0:&#xA;        ax.set_ylabel(&amp;#39;y&amp;#39;)&#xA;&#xA;    plt.subplot(2, PLOT_NUM, PLOT_NUM + i + 1)&#xA;    plt.hist(x_hisotry[:hist_num], bins=50)&#xA;    if i == 0:&#xA;        plt.ylabel(&amp;#39;histogram of x&amp;#39;)&#xA;    plt.xlabel(&amp;#39;x&amp;#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://blog.hassaku-labs.com/images/post/hyperopt/hyperopt.png&#34; alt=&#34;hyperopt&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>インスタンスを表す文字列を分かりやすくする</title>
      <link>https://blog.hassaku-labs.com/post/class-repr/</link>
      <pubDate>Sat, 04 Mar 2017 04:07:38 +0900</pubDate>
      <guid>https://blog.hassaku-labs.com/post/class-repr/</guid>
      <description>&lt;p&gt;ログとかにインスタンスの内容をダンプしたりするとき、つい適当にprintとかlogger.debugしても、&#xA;標準では、インスタンスの内容をスマートに分かりやすく表示してくれたりはしないようです。&lt;/p&gt;&#xA;&lt;p&gt;そのため、デバッグをしやすくするためにも、以下のような感じで__repr__をオーバーライドしておくと、&#xA;分かりやすくなって便利だったりします。&lt;/p&gt;&#xA;&lt;h2 id=&#34;reprを定義しない場合&#34;&gt;reprを定義しない場合&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class MyClass(object):&#xA;  def __init__(self):&#xA;    self.attr1 = 123&#xA;    self.attr2 = 456&#xA;&#xA;mc = MyClass()&#xA;print(mc)  # =&amp;gt; &amp;lt;__main__.MyClass object at 0xXXXXXXXXXX&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;reprを定義する場合&#34;&gt;reprを定義する場合&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class MyClass(object):&#xA;  def __init__(self):&#xA;    self.attr1 = 123&#xA;    self.attr2 = 456&#xA;&#xA;  def __repr__(self):&#xA;    return &amp;#34;, &amp;#34;.join(&amp;#34;%s: %s&amp;#34; % item for item in vars(self).items())&#xA;&#xA;mc = MyClass()&#xA;print(mc)  # =&amp;gt; attr2: 456, attr1: 123&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ちょっとしたTipsでした。&lt;/p&gt;</description>
    </item>
    <item>
      <title>exception-slackerというライブラリをPyPIに登録した</title>
      <link>https://blog.hassaku-labs.com/post/exception_slacker/</link>
      <pubDate>Fri, 01 Apr 2016 00:35:40 +0900</pubDate>
      <guid>https://blog.hassaku-labs.com/post/exception_slacker/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/hassaku/exception-slacker&#34;&gt;https://github.com/hassaku/exception-slacker&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;importして、Slackのtokenや投稿チャンネルなどを環境変数でセットしておけば、例外が発生した際に、以下のような感じでSlackへ投稿します。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog.hassaku-labs.com/images/post/exception_slacker/exception_slacker.png&#34; alt=&#34;exception_slacker&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;時間のかかるプロセスなどを実行している時に、いちいちコンソールをチェックする手間が省けるので、個人的に便利だと思って公開しました。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
